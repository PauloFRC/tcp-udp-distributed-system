use std::error::Error;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use prost::Message;

// This includes the Rust code generated by prost-build from our .proto file.
// The name 'main' inside the include path is derived from the protobuf package name,
// which is empty by default.
pub mod iot_system {
    include!(concat!(env!("OUT_DIR"), "/main.rs"));
}

use iot_system::{DeviceType, SensorReading, DeviceCommand};

const GATEWAY_ADDR: &str = "127.0.0.1:6788";
const DEVICE_ID: &str = "LP1";
const LOCATION: &str = "Main Street";

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    println!("[Lamp Post] Starting Lamp Post Simulator (Protobuf)...");

    // Loop to handle reconnections
    loop {
        println!("[Lamp Post] Attempting to connect to gateway at {}", GATEWAY_ADDR);
        match TcpStream::connect(GATEWAY_ADDR).await {
            Ok(mut stream) => {
                println!("[Lamp Post] Successfully connected to the gateway!");

                // --- Identification Step ---
                if let Err(e) = identify_to_gateway(&mut stream).await {
                    eprintln!("[Lamp Post] Failed to identify to gateway: {}. Reconnecting...", e);
                    tokio::time::sleep(Duration::from_secs(5)).await;
                    continue; // Go to next loop iteration to reconnect
                }

                println!("[Lamp Post] Identification successful. Listening for commands...");

                // --- Command Listening Loop ---
                if let Err(e) = listen_for_commands(&mut stream).await {
                    eprintln!("[Lamp Post] Connection error: {}. Attempting to reconnect...", e);
                }
            }
            Err(e) => {
                eprintln!("[Lamp Post] Failed to connect to gateway: {}. Retrying in 5 seconds...", e);
            }
        }
        // Wait before retrying connection
        tokio::time::sleep(Duration::from_secs(5)).await;
    }
}

/// Sends an initial identification message to the gateway.
async fn identify_to_gateway(stream: &mut TcpStream) -> Result<(), Box<dyn Error>> {
    let timestamp = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs() as i64;

    let identification_reading = SensorReading {
        device_id: DEVICE_ID.to_string(),
        location: LOCATION.to_string(),
        device_type: DeviceType::LampPost as i32,
        value: 0.0, // Initial state is OFF
        unit: "state".to_string(),
        timestamp,
    };

    // Serialize the Protobuf message to a byte vector
    let mut buf = Vec::new();
    identification_reading.encode(&mut buf)?;

    // Send the length of the message first (as a 4-byte unsigned integer)
    let len = buf.len() as u32;
    stream.write_all(&len.to_be_bytes()).await?;

    // Send the message itself
    stream.write_all(&buf).await?;
    Ok(())
}

/// Listens for commands from the gateway and acts on them.
async fn listen_for_commands(stream: &mut TcpStream) -> Result<(), Box<dyn Error>> {
    let mut len_buf = [0u8; 4]; // Buffer to read the message length
    loop {
        // 1. Read the 4-byte length prefix
        match stream.read_exact(&mut len_buf).await {
            Ok(_) => {
                let msg_len = u32::from_be_bytes(len_buf);
                let mut msg_buf = vec![0u8; msg_len as usize];

                // 2. Read the actual message
                stream.read_exact(&mut msg_buf).await?;
                
                // 3. Decode the protobuf message
                let command = DeviceCommand::decode(&msg_buf[..])?;

                println!("[Lamp Post] Received command: '{}' for target '{}'", command.command, command.target_id);

                // 4. Act on the command
                match command.command.as_str() {
                    "ON" => println!("[Lamp Post] ---> The light is now ON <---"),
                    "OFF" => println!("[Lamp Post] ---> The light is now OFF <---"),
                    _ => eprintln!("[Lamp Post] Received unknown command."),
                }
            }
            Err(e) => {
                // If read_exact fails, it usually means the connection was closed.
                return Err(Box::new(e));
            }
        }
    }
}
